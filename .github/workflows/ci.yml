name: ArchGuardian CI/CD

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        go-version: [1.22.x, 1.23.x]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for coverage analysis

    - name: Set up Go
      uses: actions/setup-go@v4
      id: go
      with:
        go-version: ${{ matrix.go-version }}
        cache: true

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential git

    - name: Download and Verify Dependencies
      run: |
        go mod download
        go mod verify

    - name: Run Go vet
      run: go vet ./...

    - name: Run go fmt check
      run: |
        if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
          echo "The following files need to be formatted:"
          gofmt -s -l .
          exit 1
        fi

    - name: Run tests with coverage
      run: |
        go test -v -race -coverprofile=coverage.out -covermode=atomic ./...

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v4
      with:
        file: ./coverage.out
        flags: unittests
        name: codecov-umbrella
        fail_ci_if_error: false

    - name: Generate coverage report
      run: |
        go tool cover -html=coverage.out -o coverage.html

    - name: Upload coverage report
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report-${{ matrix.go-version }}
        path: coverage.html

    - name: Run benchmark tests
      run: |
        go test -bench=. -benchmem ./...

    - name: Build application
      run: |
        go build -v -o archguardian ./cmd/archguardian

    - name: Test binary
      run: |
        chmod +x archguardian
        # Basic smoke test
        timeout 10s ./archguardian --help || echo "Binary test completed"

    - name: Archive test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results-${{ matrix.go-version }}
        path: |
          *.out
          *.log

  build-website:
    runs-on: ubuntu-latest
    needs: test

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '22'
        cache: 'npm'
        cache-dependency-path: 'website/package-lock.json'

    - name: Install website dependencies
      run: npm install
      working-directory: ./website

    - name: Build website
      run: npm run build
      working-directory: ./website

    - name: Archive website build
      uses: actions/upload-artifact@v4
      with:
        name: website-build
        path: website/dist/

  security:
    runs-on: ubuntu-latest
    needs: test

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      id: go
      with:
        go-version: 1.22.x

  integration:
    runs-on: ubuntu-latest
    needs: [test, build-website]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: 1.22.x
        cache: true

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Download website artifact
      uses: actions/download-artifact@v4
      with:
        name: website-build
        path: website/dist


    - name: Build Docker image
      run: |
        docker build -t archguardian:latest .

    - name: Test Docker image
      run: |
        # Start the container in background
        docker run -d --name archguardian-test \
          -e PROJECT_PATH=/app \
          -e SCAN_INTERVAL_HOURS=1 \
          -p 3000:3000 \
          archguardian:latest

        # Wait for application to start and be ready
        echo "Waiting for application to start..."
        timeout 60s bash -c ' \
          while ! curl -s -f http://localhost:3000/health > /dev/null; do \
            echo "Attempting to connect to http://localhost:3000/health..."; \
            sleep 2; \
          done'
        if [ $? -eq 0 ]; then
            echo "Application is ready!"
        else
            echo "‚ùå Application failed to start in time."
            docker logs archguardian-test
            exit 1
        fi

        # Verify application is actually responding
        echo "Testing health endpoint..."
        if ! curl -f http://localhost:3000/health; then
          echo "‚ùå Health check failed"
          docker logs archguardian-test
          exit 1
        fi

        # Test API endpoints
        echo "Testing API endpoints..."
        if ! curl -f http://localhost:3000/api/v1/knowledge-graph; then
          echo "‚ùå Knowledge graph API test failed"
          docker logs archguardian-test
          exit 1
        fi

        # Test authentication endpoints
        echo "Testing authentication endpoints..."
        if ! curl -f http://localhost:3000/api/v1/auth/github/status; then
          echo "‚ùå Auth status API test failed"
          docker logs archguardian-test
          exit 1
        fi

        # Clean up
        echo "Cleaning up test container..."
        docker stop archguardian-test || true
        docker rm archguardian-test || true

  notify:
    runs-on: ubuntu-latest
    # The build-website job is now a dependency for the notification
    # to ensure we're notified if the website build fails.
    needs: [test, security, integration, build-website]
    if: always() && (needs.test.result == 'failure' || needs.security.result == 'failure' || needs.integration.result == 'failure')

    steps:
    - name: Notify on failure
      run: |
        echo "‚ùå CI/CD pipeline failed!"
        echo "Test result: ${{ needs.test.result }}"
        echo "Security result: ${{ needs.security.result }}"
        echo "Website Build result: ${{ needs.build-website.result }}"
        echo "Integration result: ${{ needs.integration.result }}"

        # Here you could add Slack/Discord/Teams notifications
        # Example: curl -X POST -H 'Content-type: application/json' \
        #   --data '{"text":"ArchGuardian CI/CD failed!"}' \
        #   $SLACK_WEBHOOK_URL

  cleanup:
    runs-on: ubuntu-latest
    if: always()

    steps:
    - name: Cleanup artifacts
      run: |
        echo "üßπ Cleaning up old artifacts..."
        # GitHub Actions automatically cleans up old artifacts
        # but we can add custom cleanup logic here if needed
